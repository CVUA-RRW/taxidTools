{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#taxidtools-a-python-toolkit-for-taxonomy","title":"TaxidTools - A Python Toolkit for Taxonomy","text":"<p>taxidTools is a Python library to handle Taxonomy definitions.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Load taxonomy defintions for the NCBI's taxdump files</li> <li>Prune, filter, and normalize branches</li> <li>Save as JSON for later use</li> <li>Determine consensus, last common ancestor, or distances</li> <li>Retrieve ancestries or list descendants</li> <li>Export as Newick trees</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>:</p> <pre><code>pip install taxidtools\n</code></pre> <p>With <code>conda</code>:</p> <pre><code>conda install -c conda-forge taxidtools\n</code></pre> <p>With <code>docker</code>:</p> <pre><code>docker pull gregdenay/taxidtools\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>With the NCBI's taxdump files installed locally:</p> <pre><code>&gt;&gt;&gt; import taxidTools\n&gt;&gt;&gt; tax = taxidTools.read_taxdump('nodes.dmp', 'rankedlineage.dmp', 'merged.dmp')\n&gt;&gt;&gt; tax.getName('9606')\n'Homo sapiens'\n&gt;&gt;&gt; lineage = tax.getAncestry('9606')\n&gt;&gt;&gt; lineage.filter()\n&gt;&gt;&gt; [node.name for node in lineage]\n['Homo sapiens', 'Homo', 'Hominidae', 'Primates', 'Mammalia', 'Chordata', 'Metazoa']\n&gt;&gt;&gt; tax.lca(['9606', '10090']).name\n'Euarchontoglires'\n&gt;&gt;&gt; tax.distance('9606', '10090')\n18\n</code></pre>"},{"location":"#cite-us","title":"Cite us","text":"<p>If you use taxidTools for your reasearch, you can cite it using the  DOI at the top of this page.</p>"},{"location":"about/contributing/","title":"Contribution guide","text":"<p>Maintaining a repository is a lot of work and it is only possible with the input for its users. That's why we love to get your feedback and continuously improve! We want to contibuting to this project as easy and transparent as possible. That's why we ask all contributions to go through a GitHub workflow.</p>"},{"location":"about/contributing/#ask-a-question-report-a-bug-or-suggest-new-features","title":"Ask a question, report a bug, or suggest new features","text":"<p>Wether you wish to report a bug, discuss the current state of the code, how to use it, or propose new features, the GitHub repository is the place to start.</p> <p>Go to 'Issues' in the repository's menu and use the search bar to look for your issue/question, maybe the discussion already exists! if you don't find what you are looking for, use the green button 'New Issue' and select the correct template (Question, Bug report or New feature).</p>"},{"location":"about/contributing/#bug-reports","title":"Bug reports","text":"<p>Solving Bugs is not always easy and usually requires to be able to precisely understand what happened. Try to include the following in your report, so we can solve the problems quickly:</p> <ul> <li>A quick summary and/or background</li> <li>The software versions</li> <li>A precise description of the problem</li> <li>Join input data that reproduce the problem if possible</li> <li>Attach relevant log files to the issue</li> </ul>"},{"location":"about/contributing/#improving-the-documentation","title":"Improving the documentation","text":"<p>Writting a documentation is a big task and we are gratefull for any help to expand and improve it.</p> <p>If you find a specific section of the documentaiton unclear, or would like to see it in other languages, we would love to hear about it, or if you feel like it, try suggesting modifications.</p>"},{"location":"about/contributing/#writting-tests","title":"Writting tests","text":"<p>The critical parts of the workflow are currently verified by unit tests. These could always be improved and/or expanded. If you like to write tests, check the <code>tests</code> folder and suggest changes.</p>"},{"location":"about/contributing/#submitting-changes","title":"Submitting changes","text":"<p>All changes in the repository are made through pull requests.</p>"},{"location":"about/contributing/#github-worflow","title":"Github worflow","text":"<p>To submitt a pull request:</p> <ul> <li>Fork the repository and create your branch from <code>main</code></li> <li>Make your changes to the code base/documentation/tests</li> <li>If you have added code that shoul dbe testes, add tests</li> <li>If you have changed the parameters or formating of the inputs, update the documentation</li> <li>Ensure that your code passes the tests and lints, this will be automatically   tested when you submit your pull request</li> <li>Issue your pull request and wait for a maintainer to review the changes</li> </ul> <p>Please provide precise and sufficient information on the changes you performed when you submit your pull request.</p>"},{"location":"about/contributing/#tests","title":"Tests","text":"<p>It is a good idea to locally run tests before submitting your pull request.</p>"},{"location":"about/contributing/#unit-tests","title":"Unit tests","text":"<p>We use unittest for running unit tests. Make sure your current environment supports  a recent version of python (&gt;3.9).</p> <pre><code>python -m unittest discover tests\n</code></pre>"},{"location":"about/contributing/#license","title":"License","text":"<p>By submitting changes to this repository, you agree that your contributions will be licensed under its BSD-3 Clauses License.</p>"},{"location":"about/history/","title":"Release History","text":""},{"location":"about/history/#311","title":"3.1.1","text":"<p>Bugfix</p> <ul> <li><code>Taxonomy.consensus</code> now correctly handles list of taxids as int</li> </ul>"},{"location":"about/history/#310","title":"3.1.0","text":"<p>Improvements</p> <ul> <li><code>Taxonomy.consensus</code> and <code>Taxonomy.lca</code> can now ignore missing taxa instead of raising an error</li> </ul>"},{"location":"about/history/#300","title":"3.0.0","text":"<p>Deprecation</p> <ul> <li><code>Taxonomy.from_json</code>, <code>load</code>, <code>Taxonomy.from_taxdump</code> and <code>load_ncbi</code> are deprecated. See v2.4.0 notes for replacements</li> </ul> <p>New features</p> <ul> <li>It is now possible to create Newick tree with <code>Taxonomy.toNewick</code> (Experimental)</li> </ul>"},{"location":"about/history/#252","title":"2.5.2","text":"<p>Improvements</p> <ul> <li>Update docstrings</li> <li>Rework documentation</li> <li>Taxonomy.getXXX methods now behave like dict.get: allow default return value if key is not found, never raises an error</li> </ul>"},{"location":"about/history/#251","title":"2.5.1","text":"<p>Improvements</p> <ul> <li>taxidTools.InvalidNodeError now ihnerits from KeyError as well, this might be more intuitive for some users</li> </ul>"},{"location":"about/history/#250","title":"2.5.0","text":"<p>New features</p> <ul> <li>It is now possible to provide merged nodes, either form the taxdump file <code>merged.dmp</code> or directly via instances of the class <code>MergedNode</code></li> <li>Attempting to retrieve a MergedNode from a Taxonomy instance will return the node it was merged with.</li> </ul> <p>Bug Fix</p> <ul> <li>Instanciating a Lineagefrom a DummyNode doesn't raise an Error anymore</li> </ul>"},{"location":"about/history/#240","title":"2.4.0","text":"<p>New features</p> <ul> <li>Added a <code>Taxonomy.copy()</code> method as a shorthand for <code>copy.deepcopy(Taxonomy)</code></li> <li>Added an <code>inplace</code> argument to <code>Taxonomy</code> methods <code>filterRanks()</code> and <code>prune()</code>, allowing chose whether to return a modified deepcopy of the instance od modifiy it in place</li> </ul> <p>Improvements</p> <ul> <li>Unit tests now use temporary directories to test IO methods</li> <li>The <code>Taxonomy.filter()</code> method will now return a <code>ValueError</code> when attempting to use <code>root</code> rank in the filtering instead of creating new root Nodes</li> </ul> <p>Pending deprecation</p> <ul> <li><code>Taxonomy.from_json</code> will be removed in 3.0.0, it is replaced by <code>read_json</code>, a module level constructor.</li> <li><code>load</code> will be removed in 3.0.0, it is replaced by <code>read_json</code>, a module level constructor.</li> <li><code>Taxonomy.from_taxdump</code> will be removed in 3.0.0, it is replaced by <code>read_taxdump</code>, a module level constructor.</li> <li><code>load_ncbi</code> will be removed in 3.0.0, it is replaced by <code>read_ncbi</code>, a better-named module level constructor.</li> </ul> <p>Bug Fix</p> <ul> <li><code>Taxonomy.listDescendant</code> now does filter output based on the ranks parameter</li> <li>Repaired <code>Node.node_info</code> output to actually use newlines instead of printing '\\n'</li> </ul>"},{"location":"about/history/#231-2024-06-04","title":"2.3.1 (2024-06-04)","text":"<p>Distribution</p> <ul> <li>It is now possible to install taxidTools from DockerHub:</li> </ul> <pre><code>docker pull gregdenay/taxidtools\n</code></pre> <ul> <li><code>conda-forge</code> release should now auomatically find the last release from Github/Pypi</li> </ul>"},{"location":"about/history/#230-2024-05-13","title":"2.3.0 (2024-05-13)","text":"<p>New features</p> <ul> <li>Attempting to access an invalid Node with the Taxonomy getitem method (<code>Taxonomy[\"node_id\"]</code>) now returns a specifc <code>InvalidNodeError</code></li> <li>Added the <code>load_ncbi</code> function as a shorthand for the constructor <code>Taxonomy.from_taxdump</code>.</li> </ul>"},{"location":"about/history/#223-2021-10-08","title":"2.2.3 (2021-10-08)","text":"<p>Bug Fix</p> <ul> <li>Fixed an error in the listDescendant method that affected the prune and filterRanks methods.</li> </ul> <p>Performance</p> <ul> <li>Node.children attribute is now a set, considerably speeding up file loading.</li> </ul>"},{"location":"about/history/#222-2021-09-21","title":"2.2.2 (2021-09-21)","text":"<p>Bug Fix</p> <ul> <li>Fixed some bugged references to Node class</li> </ul>"},{"location":"about/history/#2202021-09-21","title":"2.2.0(2021-09-21)","text":"<p>Bug Fix</p> <ul> <li>Fixed broken implementation of <code>Taxonomy.filterRanks</code></li> </ul> <p>Implementation changes</p> <ul> <li><code>Node</code> and <code>Dummy Node</code> classes now ihnerit from the new _BaseNode classe. No impact on methods and properties.</li> </ul>"},{"location":"about/history/#212-2021-08-18","title":"2.1.2 (2021-08-18)","text":"<p>Bug Fix</p> <ul> <li>Fix a bug resulting in the deletion of the children attribute of Nodes after writing to a JSON file (#2)</li> <li>Fix an issue with the creation of DummyNdoes from JSON files (#3)</li> </ul>"},{"location":"about/history/#211-2021-07-15","title":"2.1.1 (2021-07-15)","text":"<p>Bug fix</p> <ul> <li>Fixed unlinking of removed branches in <code>Taxonomy.prune</code></li> </ul> <p>Other</p> <ul> <li>Linting code, still ignoring W293 and W291 =)</li> </ul>"},{"location":"about/history/#210-2021-07-14","title":"2.1.0 (2021-07-14)","text":"<p>Bug fix</p> <ul> <li><code>Taxonomy.filterRanks</code> now correctly handles rerooted trees</li> <li>Fixed and bug to <code>Taxonomy.consensus</code> where search would only be in range of the shortest lineage</li> </ul> <p>Changes</p> <ul> <li>Implementation of <code>Taxonomy.reroot</code> was changed to conserve the ancestry of the input taxid.</li> <li><code>Taxonomy.reroot</code> was renamed to <code>Taxonomy.prune</code></li> </ul> <p>Additions</p> <ul> <li>Added taxid search by name <code>Taxonomy.getTaxid</code></li> </ul>"},{"location":"about/history/#200-2021-07-13","title":"2.0.0 (2021-07-13)","text":"<ul> <li>Released version 2. Implementation reworked from scraps. </li> <li>NOT backwards compatible</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>Copyright 2024, Gregoire Denay.</p> <p>Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this  list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,  this list of conditions and the following disclaimer in the documentation  and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors  may be used to endorse or promote products derived from this software without  specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"api_doc/factories/","title":"Constructors","text":""},{"location":"api_doc/factories/#taxidTools.factories.read_taxdump","title":"<code>taxidTools.factories.read_taxdump(nodes, rankedlineage, merged=None)</code>","text":"<p>Read a Taxonomy from the NCBI`s taxdump files</p> <p>Parameters:</p> <ul> <li> <code>nodes</code>               (<code>str</code>)           \u2013            <p>Path to the nodes.dmp file</p> </li> <li> <code>rankedlineage</code>               (<code>str</code>)           \u2013            <p>Path to the rankedlineage.dmp file</p> </li> <li> <code>merged</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path tothe merged.mp file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Taxonomy</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tax = read_taxdump(\"nodes.dmp', 'rankedlineage.dmp')\n</code></pre> See Also <p>read_json</p>"},{"location":"api_doc/factories/#taxidTools.factories.read_json","title":"<code>taxidTools.factories.read_json(path)</code>","text":"<p>Load a Taxonomy from a previously exported json file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path of file to load</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Taxonomy</code>           \u2013            </li> </ul> See Also <p>taxidTools.Taxonomy.write read_taxdump</p>"},{"location":"api_doc/lineage/","title":"Lineage","text":""},{"location":"api_doc/lineage/#taxidTools.Lineage.Lineage","title":"<code>taxidTools.Lineage.Lineage</code>","text":"<p>               Bases: <code>UserList</code></p> <p>Taxomic Lineage</p> <p>Defines a linear and ordered succession of Nodes. A Lineage is created by providing a single Node that will be used as a base to retrieve higher Nodes. Ranks are ascending by default.</p> <p>Parameters:</p> <ul> <li> <code>base_node</code>               (<code>_BaseNode</code>)           \u2013            <p>An instance of a <code>taxidTools._BaseNode</code>subclass from which the ancestry should be retrieved</p> </li> <li> <code>ascending</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>Should the Lineage by sorted by ascending ranks?</p> </li> </ul> Notes <p>A Lineage does not have to be continuous. Nodes can have parents that are not included in the Lineage, as long as Nodes in a Lineage form a linear path.</p> <p>Lineage methods will never modify the Node objects it contains</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; child1 = Node(2, \"child1\", \"child_rank\", root)\n&gt;&gt;&gt; child2 = Node(3, \"child2\", \"sub_child_rank\", child1)\n&gt;&gt;&gt; Lineage(child2)\nLineage([Node(3), Node(2), Node(1)])\n</code></pre> <p>Lineage elements are the Node objects themselves</p> <pre><code>&gt;&gt;&gt; Lineage(child2)[-1]\nNode object:\n        Taxid: 1\n        Name: root\n        Rank: root\n        Parent: None\n</code></pre> <p>A Lineage can also be descending</p> <pre><code>&gt;&gt;&gt; Lineage(child2, ascending = False)\nLineage([Node(1), Node(2), Node(3)])\n</code></pre>"},{"location":"api_doc/lineage/#taxidTools.Lineage.Lineage.filter","title":"<code>filter(ranks=linne())</code>","text":"<p>Filter a Lineage to a set of specified ranks.</p> <p>Modifies a Lineage in-place. Lineage order will not be conserved and dummy nodes will be added as placeholders for missing ranks.</p> <p>Parameters:</p> <ul> <li> <code>ranks</code>               (<code>Optional[list[str]]</code>, default:                   <code>linne()</code> )           \u2013            <p>List of ranks to filter. It is assumed to be sorted in the same order as Lineage.</p> </li> </ul> Notes <p>The Nodes are not modified by this method! That means that Node.parent will still point to the original parent Node, even if it was masked in the Lineage.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; child1 = Node(2, \"child1\", \"child_rank\", root)\n&gt;&gt;&gt; child2 = Node(3, \"child2\", \"sub_child_rank\", child1)\n&gt;&gt;&gt; lin = Lineage(child2)\n&gt;&gt;&gt; lin.filter([\"sub_child_rank\", \"norank\", \"child_rank\"])\n&gt;&gt;&gt; lin\nLineage([Node(3), 'dummy', Node(2)])\n</code></pre> <p>Order is not conserved!</p> <pre><code>&gt;&gt;&gt; lin = Lineage(child2)\n&gt;&gt;&gt; lin.filter([\"root\", \"sub_child_rank\"])\nLineage([Node(1), Node(3)])\n</code></pre>"},{"location":"api_doc/nodes/","title":"Nodes","text":""},{"location":"api_doc/nodes/#taxidTools.Node.Node","title":"<code>taxidTools.Node.Node</code>","text":"<p>               Bases: <code>_BaseNode</code></p> <p>Taxonomic Node</p> <p>Create a Node object contining taxonomic information as well as a link to parent and children nodes.</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node name</p> </li> <li> <code>rank</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node rank</p> </li> <li> <code>parent</code>               (<code>Optional[_BaseNode]</code>, default:                   <code>None</code> )           \u2013            <p>The parent Node object</p> </li> </ul> Notes <p>The <code>children</code> property will be dynamically populated when children Nodes declare a Node as parent.</p> <p>Attributes:</p> <ul> <li> <code>taxid</code>               (<code>str</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>rank</code>               (<code>str</code>)           \u2013            </li> <li> <code>children</code>               (<code>list</code>)           \u2013            </li> <li> <code>parent</code>               (<code>str</code>)           \u2013            </li> <li> <code>node_info</code>               (<code>str</code>)           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; child = Node(2, \"child\", \"child_rank\", root)\n</code></pre> <pre><code>&gt;&gt;&gt; child.taxid\n'2'\n&gt;&gt;&gt; child.rank\n'child_rank'\n&gt;&gt;&gt; child.name\n'child'\n</code></pre> <pre><code>&gt;&gt;&gt; child.parent\nNode object:\n        Taxid: 1\n        Name: root\n        Rank: root\n        Parent: None\n</code></pre> <pre><code>&gt;&gt;&gt; root.children\n[Node object:\n        Taxid: 2\n        Name: child\n        Rank: child_rank\n        Parent: 1]\n</code></pre>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.children","title":"<code>children: list</code>  <code>property</code> <code>writable</code>","text":"<p>Children nodes</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Name of the taxonomic node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.node_info","title":"<code>node_info: str</code>  <code>property</code>","text":"<p>Node information</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.parent","title":"<code>parent: str</code>  <code>property</code> <code>writable</code>","text":"<p>Parent node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.rank","title":"<code>rank: str</code>  <code>property</code> <code>writable</code>","text":"<p>Rank of the taxonomic node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.taxid","title":"<code>taxid: str</code>  <code>property</code> <code>writable</code>","text":"<p>Taxonomic identification number</p>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.isAncestorOf","title":"<code>isAncestorOf(node)</code>","text":"<p>Test if the object is an ancestor of another Node.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>Putative descendant node</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; node.isAncestorOf(root)\nFalse\nroot.isAncestorOf(node)\nTrue\n</code></pre>"},{"location":"api_doc/nodes/#taxidTools.Node.Node.isDescendantOf","title":"<code>isDescendantOf(node)</code>","text":"<p>Test if the object is an ancestor of another Node.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>Putative ancestor node</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; node.isDescendantOf(root)\nTrue\nroot.isDescendantOf(node)\nFalse\n</code></pre>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode","title":"<code>taxidTools.Node.DummyNode</code>","text":"<p>               Bases: <code>_BaseNode</code></p> <p>A placeholder for a non-existing Node.</p> <p>Will be assigned a random hash id in place of a taxid upon creation. Can be inserted between two existing nodes.</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Optional[Union[str, int]]</code>, default:                   <code>None</code> )           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node name</p> </li> <li> <code>rank</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node rank</p> </li> <li> <code>parent</code>               (<code>Optional[_BaseNode]</code>, default:                   <code>None</code> )           \u2013            <p>The parent Node object</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>taxid</code>               (<code>str</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>rank</code>               (<code>str</code>)           \u2013            </li> <li> <code>children</code>               (<code>list</code>)           \u2013            </li> <li> <code>parent</code>               (<code>str</code>)           \u2013            </li> <li> <code>node_info</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.children","title":"<code>children: list</code>  <code>property</code> <code>writable</code>","text":"<p>Children nodes</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Name of the taxonomic node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.node_info","title":"<code>node_info: str</code>  <code>property</code>","text":"<p>Node information</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.parent","title":"<code>parent: str</code>  <code>property</code> <code>writable</code>","text":"<p>Parent node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.rank","title":"<code>rank: str</code>  <code>property</code> <code>writable</code>","text":"<p>Rank of the taxonomic node</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.taxid","title":"<code>taxid: str</code>  <code>property</code> <code>writable</code>","text":"<p>Taxonomic identification number</p>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.insertNode","title":"<code>insertNode(parent, child)</code>","text":"<p>Insert the dummy node between parent and child</p> <p>Parameters:</p> <ul> <li> <code>parent</code>               (<code>_BaseNode</code>)           \u2013            <p>Upstream node</p> </li> <li> <code>child</code>               (<code>_BaseNode</code>)           \u2013            <p>Downstream node</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.isAncestorOf","title":"<code>isAncestorOf(node)</code>","text":"<p>Test if the object is an ancestor of another Node.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>Putative descendant node</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; node.isAncestorOf(root)\nFalse\nroot.isAncestorOf(node)\nTrue\n</code></pre>"},{"location":"api_doc/nodes/#taxidTools.Node.DummyNode.isDescendantOf","title":"<code>isDescendantOf(node)</code>","text":"<p>Test if the object is an ancestor of another Node.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>Putative ancestor node</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; node.isDescendantOf(root)\nTrue\nroot.isDescendantOf(node)\nFalse\n</code></pre>"},{"location":"api_doc/nodes/#taxidTools.Node.MergedNode","title":"<code>taxidTools.Node.MergedNode</code>","text":"<p>Simple class linking to an instance of (a subclass of) _BaseNode</p> <p>Represents a taxonomic node that has been merged with another node and is therefore not part of the taxonomy anymore. This is not a subclass of _BaseNode.</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>new_node</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxid of node this node has been merged with</p> </li> <li> <code>*args</code>           \u2013            <p>ignored</p> </li> <li> <code>**kwargs</code>           \u2013            <p>ignored</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>taxid</code>               (<code>str</code>)           \u2013            </li> <li> <code>new_node</code>               (<code>str</code>)           \u2013            </li> </ul> Note <p><code>new_node</code> is provided as a taxid and not as an instance of a Node class. An Error will be raised upon trying to access a MergedNode from Taxonomy object if it is linked to a non-existing Node.</p>"},{"location":"api_doc/nodes/#taxidTools.Node.MergedNode.new_node","title":"<code>new_node: str</code>  <code>property</code> <code>writable</code>","text":"<p>Node this node has been merged with</p>"},{"location":"api_doc/nodes/#taxidTools.Node.MergedNode.taxid","title":"<code>taxid: str</code>  <code>property</code> <code>writable</code>","text":"<p>Taxonomic identification number</p>"},{"location":"api_doc/taxonomy/","title":"Taxonomy","text":""},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy","title":"<code>taxidTools.Taxonomy.Taxonomy</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>Stores Taxonomy nodes and their relationships</p> <p>A Taxonomy is instanciated as a dictionnary and each Node can be accessed by its taxid. A Taoxonomy object can be instanciated directly from a dictionnary, iteratively with the method <code>Taxonomy.addNode</code> method or from a list of taxdump files..</p> <p>Attributes:</p> <ul> <li> <code>root</code>               (<code>Node</code>)           \u2013            </li> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>data store</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>InvalidNodeError</code>             \u2013            <p>If trying to access a Node that doesn't exist with a bracket expression</p> </li> </ul> Notes <p>Taxonomy objects are mutable and some methods will modify the underlying Node objects. Do a deep copy or use the Taxonomy.copy() method if you wish to keep the original object.</p> <p>A Taxonomy always assumes a unique root node.</p> See Also <p>Taxonomy.from_list: load a Taxonomy object from a list of Node read_taxdump: load a Taxonomy object from taxdump files read_json: load a Taxonomy from a previously exported json file Taxonomy.addNode: add a Node to a Taxonomy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; branch1 = Node(11, \"node11\", \"middle\", root)\n&gt;&gt;&gt; branch2 = Node(12, \"node12\", \"middel\", root)\n&gt;&gt;&gt; leaf1 = Node(111, \"node111\", \"leaf\", branch1)\n&gt;&gt;&gt; leaf2 = Node(112, \"node112\", \"leaf\", branch1)\n&gt;&gt;&gt; leaf3 = Node(121, \"node121\", \"leaf\", branch2)\n&gt;&gt;&gt; leaf4 = Node(13, \"node13\", \"leaf\", root)\n</code></pre> <p>From a dictionnary of Nodes:</p> <pre><code>&gt;&gt;&gt; tax = Taxonomy({\"1\" : root,\n...     11: branch1,\n...     12: branch2,\n...     111: leaf1,\n...     112: leaf2,\n...     121: leaf3,\n...     13: leaf4})\n</code></pre> <p>Instanciate from a list:</p> <pre><code>&gt;&gt;&gt; tax = Taxonomy.from_list(\n    [root, branch1, branch2, leaf1, leaf2, leaf3, leaf4])\n</code></pre> <p>Or iteratively:</p> <pre><code>&gt;&gt;&gt; tax = Taxonomy()\n&gt;&gt;&gt; for node in [root, branch1, branch2, leaf1, leaf2, leaf3, leaf4]:\n...     tax.addNode(node)\n...\n</code></pre> <p>Or from the taxdump files:</p> <pre><code>&gt;&gt;&gt; tax = Taxonomy.read_taxdump(\"nodes.dmp', 'rankedlineage.dmp', 'merged.dmp')\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.root","title":"<code>root: Node</code>  <code>property</code>","text":"<p>Returns the root Node, assumes a single root shared by all Nodes</p>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Element getter with brackets</p> <p>Overloading default behavior to: - return a specific error on non-existing key - handle MergedNodes to return the new node</p>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.addNode","title":"<code>addNode(node)</code>","text":"<p>Add a Node to an existing Taxonomy object.</p> <p>The Node taxid will be used a key to access element.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>A Node to add to the Taxonomy</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tax = Taxonomy()\n&gt;&gt;&gt; tax.addNode(Node(1))\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.consensus","title":"<code>consensus(taxid_list, min_consensus, ignore_missing=False)</code>","text":"<p>Find a taxonomic consensus for the given taxid with a minimal agreement level.</p> <p>Parameters:</p> <ul> <li> <code>taxid_list</code>               (<code>list[Union[str, int]]</code>)           \u2013            <p>list of taxonomic identification numbers</p> </li> <li> <code>min_consensus</code>               (<code>float</code>)           \u2013            <p>minimal consensus level, between 0.5 and 1. Note that a minimal consensus of 1 will return the same result as <code>lastCommonNode()</code></p> </li> <li> <code>ignore_missing</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True will ignore missing taxids form the analysis. If False (default), will raise an Error on missing taxids</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_BaseNode</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>taxid_list</code> contains no valid taxid and <code>ignore_missing</code> is <code>True</code></p> </li> <li> <code>InvalidNodeError</code>             \u2013            <p>If <code>taxid_list</code> contains invalid taxids and <code>ignore_missing</code> is <code>False</code></p> </li> </ul> Notes <p>If no consensus can be found (for example because the Taxonomy contains multiple trees), an <code>IndexError</code> will be raised.</p> See Also <p>Taxonomy.lca</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node0 = Node(taxid = 0, name = \"root\",\n                 rank = \"root\", parent = None)\n&gt;&gt;&gt; node1 = Node(taxid = 1, name = \"node1\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node2 = Node(taxid = 2, name = \"node2\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node11 = Node(taxid = 11, name = \"node11\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; node12 = Node(taxid = 12, name = \"node12\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node0, node1, node2, node11, node12])\n&gt;&gt;&gt; tax.consensus([11, 12, 2], 0.8)\nNode(0)\n&gt;&gt;&gt; tax.consensus([11, 12, 2], 0.6)\nNode(1)\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.copy","title":"<code>copy()</code>","text":"<p>Create a deepcopy of the current Taxonomy instance.</p> <p>Equivalent to running copy.deepcopy()</p> <p>Returns:</p> <ul> <li> <code>Taxonomy</code>           \u2013            </li> </ul>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.distance","title":"<code>distance(taxid1, taxid2)</code>","text":"<p>Measures the distance between two nodes.</p> <p>Parameters:</p> <ul> <li> <code>taxid1</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>taxid2</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node0 = Node(taxid = 0, name = \"root\",\n                 rank = \"root\", parent = None)\n&gt;&gt;&gt; node1 = Node(taxid = 1, name = \"node1\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node2 = Node(taxid = 2, name = \"node2\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node11 = Node(taxid = 11, name = \"node11\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; node12 = Node(taxid = 12, name = \"node12\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node0, node1, node2, node11, node12])\n&gt;&gt;&gt; tax.distance(11, 2)\n3\n&gt;&gt;&gt; tax.distance(11, 12)\n2\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.filterRanks","title":"<code>filterRanks(ranks=linne(), inplace=True)</code>","text":"<p>Filter a Taxonomy to keep only the ranks provided as arguments.</p> <p>Modifies Taxonomy in-place to keep only the Nodes at the requested ranks. Nodes will be modified to conserve linkage in the Taxonomy.</p> <p>Parameters:</p> <ul> <li> <code>ranks</code>               (<code>Optional[list[str]]</code>, default:                   <code>linne()</code> )           \u2013            <p>List of ranks to keep. Must be sorted by ascending ranks.</p> </li> <li> <code>inplace</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>perfrom the operation inplace and mutate the underlying objects or return a mutated copy of the instance, keep the original unchanged</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Notes <p>In order to enforce ankering of the Taxonomy, the root node will always be kept.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node1 = Node(1, rank = \"root\")\n&gt;&gt;&gt; node11 = Node(11, rank = \"rank1\", parent = node1)\n&gt;&gt;&gt; node111 = Node(111, rank = \"rank2\", parent = node11)\n&gt;&gt;&gt; node001 = Node('001', rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node1, node11, node111, node001])\n&gt;&gt;&gt; tax.filterRanks(['rank2', 'rank1', 'root'])\n&gt;&gt;&gt; tax\n{Node(1), Node(11), DummyNode(tO841ymu), Node(111), Node(001)}\n</code></pre> <p>DummyNodes are created as placeholders for missing ranks in the taxonomy:</p> <pre><code>&gt;&gt;&gt; node001.parent\nDummyNode(tO841ymu)\n</code></pre> <p>Note that the root will be kept regardless of the input:</p> <pre><code>&gt;&gt;&gt; node1 = Node(1, rank = \"root\")\n&gt;&gt;&gt; node11 = Node(11, rank = \"rank1\", parent = node1)\n&gt;&gt;&gt; node111 = Node(111, rank = \"rank2\", parent = node11)\n&gt;&gt;&gt; node001 = Node('001', rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node1, node11, node111, node001])\n&gt;&gt;&gt; tax.filterRanks(['rank2', 'rank1'])\n&gt;&gt;&gt; tax\n{DummyNode(wmnar5QT), Node(001), Node(1), Node(11), Node(111)}\n</code></pre> <p>It is also possible to keep the original instance intact and return a filtered copy:</p> <pre><code>&gt;&gt;&gt; new = tax.filterRanks(['rank1'], inplace=False)\n&gt;&gt;&gt; new\n{DummyNode(wmnar5QT), Node(1), Node(11)}\n&gt;&gt;&gt; tax\n{DummyNode(wmnar5QT), Node(001), Node(1), Node(11), Node(111)}\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.from_list","title":"<code>from_list(node_list)</code>  <code>classmethod</code>","text":"<p>Create a Taxonomy object from a list of Nodes</p> <p>Convert a list of Nodes into a valid Taxonomy object where each Node can be accessed using its taxid as key.</p> <p>Parameters:</p> <ul> <li> <code>node_list</code>               (<code>list[_BaseNode]</code>)           \u2013            <p>List of Node objects</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Taxonomy</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; txd = Taxonomy.from_list([Node(1), Node(2)])\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getAncestry","title":"<code>getAncestry(taxid)</code>","text":"<p>Retrieve the ancestry of the given taxid</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lineage</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; tax = Taxonomy({'1': root, '2': node})\n&gt;&gt;&gt; tax.getAncestry(2)\nLineage([Node(2), Node(1)])\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getChildren","title":"<code>getChildren(taxid, value=None)</code>","text":"<p>Retrieve the children Nodes</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>value</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>A value to return if name does not exist</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; tax = Taxonomy({'1': root, '2': node})\n&gt;&gt;&gt; tax.getChildren(1)\n[Node(2)]\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getName","title":"<code>getName(taxid, value=None)</code>","text":"<p>Get taxid name</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>value</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>A value to return if name does not exist</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(1, \"node\", \"rank\")\n&gt;&gt;&gt; tax = Taxonomy({'1':node})\n&gt;&gt;&gt; tax.getName(1)\n'node'\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getParent","title":"<code>getParent(taxid, value=None)</code>","text":"<p>Retrieve parent Node</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>value</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>A value to return if name does not exist</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_BaseNode</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; tax = Taxonomy({'1': root, '2': node})\n&gt;&gt;&gt; tax.getParent(2)\nNode(1)\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getRank","title":"<code>getRank(taxid, value=None)</code>","text":"<p>Get taxid rank</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>value</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>A value to return if name does not exist</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(1, \"node\", \"rank\")\n&gt;&gt;&gt; tax = Taxonomy({'1':node})\n&gt;&gt;&gt; tax.getRank(1)\n'rank'\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.getTaxid","title":"<code>getTaxid(name, value=None)</code>","text":"<p>Get taxid from name</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>Union[int, str]</code>)           \u2013            <p>Node name</p> </li> <li> <code>value</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>A value to return if name does not exist</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(1, \"node\", \"rank\")\n&gt;&gt;&gt; tax = Taxonomy({'1':node})\n&gt;&gt;&gt; tax.getTaxid('node')\n'1'\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.isAncestorOf","title":"<code>isAncestorOf(taxid, child)</code>","text":"<p>Test if taxid is an ancestor of child</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>child</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            </li> </ul> See Also <p>Taxonomy.isDescendantOf</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; tax = Taxonomy({'1': root, '2': node})\n&gt;&gt;&gt; tax.isAncestorOf(1, 2)\nTrue\n&gt;&gt;&gt; tax.isAncestorOf(2, 1)\nFalse\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.isDescendantOf","title":"<code>isDescendantOf(taxid, parent)</code>","text":"<p>Test if taxid is an descendant of parent</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>parent</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            </li> </ul> See Also <p>Taxonomy.isAncestorOf</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root = Node(1, \"root\", \"root\")\n&gt;&gt;&gt; node = Node(2, \"node\", \"rank\", root)\n&gt;&gt;&gt; tax = Taxonomy({'1': root, '2': node})\n&gt;&gt;&gt; tax.isDescendantOf(1, 2)\nFalse\n&gt;&gt;&gt; tax.isDescendantOf(2, 1)\nTrue\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.lca","title":"<code>lca(taxid_list, ignore_missing=False)</code>","text":"<p>Get lowest common node of a bunch of taxids</p> <p>Parameters:</p> <ul> <li> <code>taxid_list</code>               (<code>list[Union[str, int]]</code>)           \u2013            <p>list of taxonomic identification numbers</p> </li> <li> <code>ignore_missing</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True will ignore missing taxids form the analysis. If False (default), will raise an Error on missing taxids</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_BasNode</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>taxid_list</code> contains no valid taxid and <code>ignore_missing</code> is <code>True</code></p> </li> <li> <code>InvalidNodeError</code>             \u2013            <p>If <code>taxid_list</code> contains invalid taxids and <code>ignore_missing</code> is <code>False</code></p> </li> </ul> See Also <p>Taxonomy.consensus</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node0 = Node(taxid = 0, name = \"root\",\n                 rank = \"root\", parent = None)\n&gt;&gt;&gt; node1 = Node(taxid = 1, name = \"node1\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node2 = Node(taxid = 2, name = \"node2\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node11 = Node(taxid = 11, name = \"node11\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; node12 = Node(taxid = 12, name = \"node12\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node0, node1, node2, node11, node12])\n&gt;&gt;&gt; tax.lca([11, 12, 2])\nNode(0)\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.listDescendant","title":"<code>listDescendant(taxid, ranks=None)</code>","text":"<p>List all descendant of a node</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>Taxonomic identification number</p> </li> <li> <code>ranks</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>list of ranks for which to return nodes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node0 = Node(taxid = 0, name = \"root\",\n                 rank = \"root\", parent = None)\n&gt;&gt;&gt; node1 = Node(taxid = 1, name = \"node1\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node2 = Node(taxid = 2, name = \"node2\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node11 = Node(taxid = 11, name = \"node11\", #\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; node12 = Node(taxid = 12, name = \"node12\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node0, node1, node2, node11, node12])\n&gt;&gt;&gt; tax.listDescendant(1)\n[Node(11), Node(12)]\n&gt;&gt;&gt; tax.listDescendant(2)\n[]\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.prune","title":"<code>prune(taxid, inplace=True)</code>","text":"<p>Prune the Taxonomy at the given taxid</p> <p>Nodes not in the lineage (upwards and downwards) of the given taxid will be discarded. The Ancestors of the given taxid will be kept!</p> <p>Parameters:</p> <ul> <li> <code>taxid</code>               (<code>Union[str, int]</code>)           \u2013            <p>taxid whose Lineage to keep</p> </li> <li> <code>inplace</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>perfrom the operation inplace and mutate the underlying objects or return a mutated copy of the instance, keep the original unchanged</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node0 = Node(taxid = 0, name = \"root\",\n                 rank = \"root\", parent = None)\n&gt;&gt;&gt; node1 = Node(taxid = 1, name = \"node1\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node2 = Node(taxid = 2, name = \"node2\",\n                 rank = \"rank1\", parent = node0)\n&gt;&gt;&gt; node11 = Node(taxid = 11, name = \"node11\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; node12 = Node(taxid = 12, name = \"node12\",\n                  rank = \"rank2\", parent = node1)\n&gt;&gt;&gt; tax = Taxonomy.from_list([node0, node1, node2, node11, node12])\n&gt;&gt;&gt; tax.prune(1)\n</code></pre> <p>Ancestry is kept</p> <pre><code>&gt;&gt;&gt; tax.getAncestry(11)\nLineage([Node(11), Node(1), Node(0)])\n</code></pre> <p>But other branches are gone</p> <pre><code>&gt;&gt;&gt; tax.get('2')\nNone\n</code></pre> <p>We can keep a copy of the:</p> <pre><code>&gt;&gt;&gt; new = tax.prune(11, inplace=False)\n&gt;&gt;&gt; new.get('12')\nKeyError: '12'\n&gt;&gt;&gt; tax.getAncestry('12')\nLineage([Node(12), Node(1), Node(0)])\n</code></pre>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.toNewick","title":"<code>toNewick(names='name')</code>","text":"<p>Generate a Newock string fro the current taxonomy</p> <p>Export as Newick tree string for compatibility with other packages Import in ETE with format 8 (all names). Experimental feature</p> <p>Parameters:</p> <ul> <li> <code>names</code>               (<code>str</code>, default:                   <code>'name'</code> )           \u2013            <p>Node attribute to use as node name, choice of 'name' or 'taxid'</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul>"},{"location":"api_doc/taxonomy/#taxidTools.Taxonomy.Taxonomy.write","title":"<code>write(path)</code>","text":"<p>Write taxonomy to a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>File path for the output</p> </li> </ul> See Also <p>taxidTools.read_json</p>"},{"location":"recipes/verify_blast/","title":"Comparing taxonomic assignement results to expectations","text":"<p>Let's say we assigned some sequences (let's say a OTUs) to taxonomic nodes using  a classifier of any kind. In practice this could be BLAST or SINTAX or anything of the like. We now want to verify whether the classifier results are in agreement with the expected composition of the sample to calculate to performance  of a method for example.</p> <p>First things first, let`s load the taxdump file in a Taxonomy object:</p> <pre><code>import taxidTools\ntax = taxidTools.read_taxdump(\"nodes.dmp\", \"rankedlineage.dmp\", \"merged.dmp\")\n</code></pre>"},{"location":"recipes/verify_blast/#getting-a-taxid-for-each-sequence","title":"Getting a taxid for each sequence","text":""},{"location":"recipes/verify_blast/#from-sintax","title":"From SINTAX","text":"<p>If we used a bayesian classifier like SINTAX, we have one assignement per sequence, usually with  a score of some sort, for example:</p> <pre><code>Bos genus   0.8\nGallus gallus   species 0.9\n</code></pre> <p>In order to work with these nodes later we want to create a list of Nodes from this output:</p> <pre><code>names = [\"Bos\", \"Gallus gallus\"] # (1)!\n\ntaxids = [tax.getTaxid(n) for n in names]\nnodes = [tax[t] for t in taxids]\n</code></pre> <ol> <li>This line is here to enable you to follow along by pasting code in your interpreter,      in practice you should parse the names form the result file!</li> </ol>"},{"location":"recipes/verify_blast/#from-blast","title":"From BLAST","text":"<p>If we used an alignement software like BLAST, we most likely have a list of hits for each  one of our sequences. BLAST can typically output taxids directly, otherwise get taxids from the  names like above. Let`s say we parsed our BLAST file in a list of list of taxids. Each element of the outer list is a list of hits for a single sequence:</p> <pre><code>res = [\n    [9913, 9913, 72004],\n    [9031, 9031]\n]\n</code></pre> <p>Ideally we would like to have a single assignement for each sequence. We can do this by assigning the last common ancestor  of all the hits for this sequence, or use a less stringent approach, like a majority agreement:</p> <pre><code>nodes = [tax.consensus(ids, 0.51, ignore_missing=True) for ids in res] # (1)!\n</code></pre> <ol> <li>The <code>ignore_missing</code> argument allows us to ignore taxids that could have been removed during taxonomy filtering without raising an error</li> </ol> <p>We now have a single Node object for each sequence, neatly organized in a list!</p>"},{"location":"recipes/verify_blast/#comparing-to-expected-composition","title":"Comparing to expected composition","text":"<p>In order to verify that our results are correct, we want to compare  this list to a list of expected taxids, for example Bos taurus (cattle) and  Gallus gallus (chicken), bot at the species level:</p> <pre><code>expected = [9913, 9031] \n</code></pre> <p>Now we don't nescessarily have a consensus at the species rank for each sequence, and that's often perfectly fine. One approach to compare the two lists is to determine to which expected  component each sequence could correspond, and then to get the rank at which they meet, effectively  determining the degree of aggreement.</p> <p>The easiest way to do this is to calculate the distance between the sequence assignement and each of the  expected components. The smallest distance indicates the correponding expected component. One has to keep in mind that different branches of the taxonomy can have a wildly different number of nodes, so it can greatly simplify things first normalize to taxonomy for such an approach:</p> <pre><code>norm = tax.filterRanks(inplace=False) # (1)!\n\ndistances = []\nfor n in nodes: # (2)!\n    distances.append(\n        [norm.distance(n.taxid, e) for e in expected]\n    )\n\nindex_corr = [d.index(min(d)) for d in distances] # (3)!\n</code></pre> <ol> <li>This uses the default filtering with Linean ranks.</li> <li>The <code>nodes</code>list contains <code>Node</code> instaces, so we need to access its attributes (<code>taxid</code>, <code>rank</code>) through a dot notation.</li> <li>Here we get the index of the taxid with the minimal distance</li> </ol> <p>Now that we have a list which links each consensus to the index of its closest match in the list of  expected species, it is straightforward to determine the agreement rank between result and expectation:</p> <pre><code>ranks = []\nfor i in range(len(nodes)):\n    ranks.append(\n        tax.lca(\n            [nodes[i].taxid, expected[index_corr[i]]],\n            ignore_missing=True\n        ).rank\n    )\n</code></pre> <p>The last step for us is to assign each result to a binary value (positiv/negativ) that we can later use to build a confusion matrix and calculate performance values like recall or precision. Let's say we want to determine these values at the genus resolution. The advantage of normalizing  the taxonomy earlier is that we don't need to care about the precise order of ranks in each branch, we can simply check wether the agreement rank in either of 'genus' or 'species':</p> <pre><code>[True if r in ['genus', 'species'] else False for r in ranks]\n</code></pre>"},{"location":"recipes/verify_blast/#unnormalized-taxonomy","title":"Unnormalized taxonomy","text":"<p>Of course it is possible to follow a similar approach without normalizing the taxonomy. It is however slightly more complicated. For example checking wether Bos taurus (9913) consensus (here genus) is under the genus level involves determining the correpsonding expected node with the unnormalized taxonomy. The trick here is to calculate the distance to the last common ancestor so that different branches length  don't bias the analysis:</p> <pre><code>distances = [tax.distance(\n                9913,\n                tax.lca([9913, e], ignore_missing=True).taxid\n    ) for e in expected]\nindex_corr = distances.index(min(distances))\nagreement = expected[index_corr]\n</code></pre> <p>Now instead of simply checking the rank of the agreement, we will rather determine the ancestor node of the expected species at the required resolution:</p> <pre><code>lin = tax.getAncestry(agreement)\nlin.filter(['genus'])\ntarget = lin[0]\n</code></pre> <p>Now the last common ancestor of our result and the corresponding expected species is either an ancestor of <code>target</code>, in which case the result did not reach the expected resolution, or its descendant or the target itself, in which case the required resolution is attained:</p> <pre><code>not tax.isAncestorOf( # (1)!\n    target.taxid,\n    tax.lca([agreement, 9913], ignore_missing=True)\n)\n</code></pre> <ol> <li>We added <code>not</code> in order to have the results in the same form as previously.</li> </ol>"},{"location":"usage/advanced/","title":"Advanced usage","text":"<p>If you mastered the basic operations on Taxonomies, here are some more advances uses.</p>"},{"location":"usage/advanced/#a-word-of-caution-on-mutable-types","title":"A word of caution on mutable types","text":"<p>All three object types in this package are mutable types. That means that methods will modify the object rather than return a new instance of the class.</p> <p>However a big difference exists between Lineage and Taxonomy objects: * Lineages are used as simple references to Nodes, therefore methods  modifying a Lineage, such as <code>Lineage.filter</code> will never mutate the underlying  Node objects. * Taxonomy are a description of the nodes relationships. Therefore methods  modifying the Taxonomy such as <code>Taxonomy.reroot</code>, <code>Taxonomy.filterRanks</code> do  modify at least some of the underlying nodes. This is nescessary to relink  Nodes after unwanted ranks have been discarded in the case of <code>filterRanks</code> for example.</p> <p>Should you want to keep a copy of the original Taxonomy (and the Nodes), you should  do a copy:</p> <pre><code>&gt;&gt;&gt; backup = tax.copy()\n</code></pre> <p>Alternatively you can save the Taxonomy in JSON format for a later use (see next sections).</p>"},{"location":"usage/advanced/#consensus-determination","title":"Consensus determination","text":"<p>Determining a consensus node from a bunch of taxid can be done as easily as:</p> <pre><code>&gt;&gt;&gt; tax.lca(['9606', '10090']).name  # Mice and men\n'Euarchontoglires'\n</code></pre> <p>However, sometimes you may want to determine a consensus node dependent on the  frequencies of a bunch of taxids. You can set a minimal frequency threshold (between 0.5 and 1). As soon a a single node meets this threshold, it will be returned as a consensus. If this threshold is  not met with the given input, then the parents of the input will be considered, and so on.</p> <pre><code>&gt;&gt;&gt; tax_list = ['9606']*6 + ['314146']*3 + ['4641']*8  # Mice and men and bananas\n&gt;&gt;&gt; tax.consensus(tax_list, 0.51).name\n'Euarchontoglires'\n&gt;&gt;&gt; tax.consensus(tax_list, 1).name\n'Eukaryota'\n</code></pre>"},{"location":"usage/advanced/#distances","title":"Distances","text":"<p>Distance between two nodes is straightforward to calculate:</p> <pre><code>&gt;&gt;&gt; tax.distance('9606', '10090')\n18\n</code></pre> <p>Note that if you want to compare distances it could be a good idea to normalize the taxonomy  first in order to impose homogeneous ranks across lineages (see next section).</p>"},{"location":"usage/advanced/#rerooting-filtering-and-normalizing-taxonomies","title":"Rerooting, filtering and normalizing taxonomies","text":"<p>If you don't care about part of the Taxonomy  you can extract a subtree and/or filter the Taxonomy to keep only specific  ranks.</p> <pre><code>&gt;&gt;&gt; tax.prune('40674') # mammals class\n&gt;&gt;&gt; tax.filterRanks(['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'])\n&gt;&gt;&gt; tax.getAncestry('9606')\nLineage([Node(9606), Node(9605), Node(9604), Node(9443), Node(40674), Node(7711), Node(33208), Node(1)])\n</code></pre> <p>Note that the <code>Taxonomy.prune</code> method does not excatly cut the tree at the given node  but rather supresses all other branches and leaves the ancestry of this node. This is by design and allows to keep ancestries up to the root node.</p> <p>Normalizing a Taxonomy using <code>Taxonomy.filterRanks</code> can be especially useful to calculate internode distances or comparing Lineages. When requesting a rank  which nodes are missing, these nodes will be replaced by a DummyNode. These special kind of nodes act as place-holders for non-existing nodes.</p> <pre><code>&gt;&gt;&gt; tax.filterRanks(['species', 'subgenus', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'])\n&gt;&gt;&gt; tax.getAncestry('9606')\nLineage([Node(9606), DummyNode(AAeFFWcs), Node(9605), Node(9604), Node(9443), Node(40674), \nNode(7711), Node(33208), Node(1)])\n</code></pre> <p>Note that the above methods mutate the nodes:</p> <pre><code>&gt;&gt;&gt; tax.getParent('9606')\nDummyNode(AAeFFWcs)\n&gt;&gt;&gt; tax.getRank('AAeFFWcs')\n'subgenus'\n</code></pre> <p>The formatted Linaean taxonomy ranks can be retrieved from the utility function <code>linne()</code> for use in diverse methods:</p> <pre><code>&gt;&gt;&gt; taxidTools.linne()\n['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom']\n&gt;&gt;&gt; tax.filterRanks(taxidTools.linne())\n&gt;&gt;&gt; tax.getAncestry('9606')\nLineage([Node(9606), Node(9605), Node(9604), Node(9443), Node(40674), Node(7711), Node(33208), Node(1)])\n</code></pre>"},{"location":"usage/advanced/#reading-and-writing-taxonomies","title":"Reading and writing taxonomies","text":"<p>As you probably already noticed, parsing the Taxonomy definition can  take a couple of minutes. If you plan on regularly using a subset of the Taxonomy,  it can be beneficial to save a filtered version to a JSON file and to reload it later.</p> <pre><code>&gt;&gt;&gt; tax.write(\"my_filtered_taxonomy.json\")\n&gt;&gt;&gt; new_tax = taxidTools.read_json(\"my_filtered_taxonomy.json\")\n</code></pre>"},{"location":"usage/advanced/#working-with-non-ncbi-taxonomies","title":"Working with non-NCBI taxonomies","text":"<p>Creating a Taxonomy object can also be done without the Taxdump files. You can either manually create Nodes and build a Taxonomy from them:</p> <pre><code>&gt;&gt;&gt; root = taxidTools.Node(taxid = 1, name = 'root', rank = 'root')\n&gt;&gt;&gt; node1 = taxidTools.Node(taxid = 2, name = 'node1', rank = 'rank1', parent = root)\n&gt;&gt;&gt; tax = taxidTools.Taxonomy.from_list([root, node1])\n&gt;&gt;&gt; node2 = taxidTools.Node(taxid = 3, name = 'node2', rank = 'rank1', parent = root)\n&gt;&gt;&gt; tax.addNode(node2)\n</code></pre> <p>If you have a Taxonomy definition file, the best thing to do is to create a parsing function to: * Create Node objects * Link parents and children * Create a Taxonomy</p> <p>Here is a boilerplate code for such a function, assuming that each node  is defined on a single line:</p> <pre><code>def custom_parser(file):\n    # Create two empty dict that will store the node\n    # information and parent information respectively\n    txd = {} \n    parent_dict = {}\n\n    # Creating nodes\n    with open(file, 'r') as fi:\n        # Parse file information, one node record at a time\n        for line in fi.readlines():\n            # Get the taxid field and so on for the other fields\n            taxid = line.split(sep)[index]\n            name = ...\n            rank = ...\n            parent = ...\n\n            # Create nodes\n            txd[taxid] = Node(taxid, name = name, rank = rank)\n            # need to delay parent linking as the parent node might not exist yet\n            parent_dict[taxid] = parent\n\n    # Update parent info now that all Nodes are created\n    for k, v in parent_dict.items():\n        txd[k].parent = txd[v]\n\n    return taxidTools.Taxonomy(txd)\n</code></pre> <p>Also check the implementations of <code>read_taxdump</code> and <code>read_json</code> for  specific examples.</p>"},{"location":"usage/quickstart/","title":"Quickstart guide","text":"<p>No time to read everything, here is how to start using the package:</p> <p>Make sure that: * taxidTools is installed * You have a local copy of the NCBI taxdump files</p> <p>While you can use the package with other taxonomy definitions (or none!), using the Taxdump files is the easiest solution.</p>"},{"location":"usage/quickstart/#loading-taxonomy-information","title":"Loading taxonomy information","text":"<p>Start by importing taxidTools:</p> <pre><code>&gt;&gt;&gt; import taxidTools\n</code></pre> <p>Then load the taxdump files that you saved and unpacked locally:</p> <pre><code>&gt;&gt;&gt; tax = taxidTools.read_taxdump(\n        \"path/to/nodes.dmp\", \n        \"path/to/rankedlineage.dmp\",\n        \"path/to/merged.dmp\"\n)\n</code></pre> <p>Parsing the whole files can take a moment!  Speeding up this process will be discussed in the advanced usage section.</p> <p>The nodes.dmp and rankedlineage.dmp are the only files you need from the taxdump archive. </p>"},{"location":"usage/quickstart/#accessing-node-infos","title":"Accessing node infos","text":"<p>A Taxonomy object contains a bunch of nodes that represent individual branchings or organisms within the clasification.</p> <p>Each node has three basic properties: * A unique identifier (taxid) * A name, scientific or common. Beware that these names are not  nescessarily unique and may be shared by several nodes. * A rank, representing where this node is place in the taxonomy. Some ranks are unique (e.g. species or genus) but some other appear at different heights in the Taxonomy (e.g. clade or the well named norank).</p> <p>Additionally each node has a single parent, the node directly above it in the Taxonomy, and can have any number of children. The only parent-less node is refered to as root node and represents the top of the taxonomy.</p> <p>All these properties can be easily accessed, using the taxid number:</p> <pre><code>&gt;&gt;&gt; tax.getName('9606')\n'Homo sapiens'\n&gt;&gt;&gt; tax.getRank('9606')\n'species'\n&gt;&gt;&gt; tax.getParent('9606')\nNode(9605)\n&gt;&gt;&gt; tax.getChildren('9606')\n[Node(63221), Node(744458)]\n</code></pre> <p>It is also possible to etrieve the taxid number for a name. However be careful that this can lead to unexpected results if the names are not unique!</p> <pre><code>&gt;&gt;&gt; tax.getTaxid('Homo sapiens')\n'9606'\n&gt;&gt;&gt; tax.addNode(Node(taxid = 0, name = 'Homo sapiens'))\n&gt;&gt;&gt; tax.getTaxid('Homo sapiens')\n'0'\n</code></pre> <p>You probably notices that some methodes return a Node object.  These are the basic objects containing all of the node information.  Actually the Taxonomy object is just a dictionnary of Nodes. You can access a Node object directly by passing its taxid as a key to a Taxonomy object and retrieve the Node properties:</p> <pre><code>&gt;&gt;&gt; hs = tax.get('9606')\n&gt;&gt;&gt; hs.name\n'Homo sapiens'\n&gt;&gt;&gt; hs.rank\n'species'\n&gt;&gt;&gt; hs.parent\nNode(9605)\n&gt;&gt;&gt; hs.parent.name\n'Homo'\n&gt;&gt;&gt; [node.name for node in hs.children]\n['Homo sapiens neanderthalensis', \"Homo sapiens subsp. 'Denisova'\"]\n</code></pre>"},{"location":"usage/quickstart/#ancestries","title":"Ancestries","text":"<p>It is possible to test directly the relationships betwen two nodes. Note that a Node is neither an ancestor or descendant of itself.</p> <pre><code>&gt;&gt;&gt; tax.isDescendantOf('9606', '9605')\nTrue\n&gt;&gt;&gt; tax.isAncestorOf('9606', '9605')\nFalse\n&gt;&gt;&gt; tax.isAncestorOf('9606', '9606')\nFalse\n</code></pre> <p>It is also possible to retrieve the whole ancestry of a given node.  Ancestries are stored in list-like Lineage objects, Nodes indices follow  the taxonomy order.</p> <pre><code>&gt;&gt;&gt; lin = tax.getAncestry('9606')\n&gt;&gt;&gt; lin[0]\nNode(9606)\n&gt;&gt;&gt; len(lin)\n32\n</code></pre> <p>It is possible to filter a Lineage for specific ranks:</p> <pre><code>&gt;&gt;&gt; lin.filter(['genus', 'family'])\n&gt;&gt;&gt; lin\nLineage([Node(9605), Node(9604)])\n</code></pre> <p>This mutates the Lineage object, if you want to keep the object intact you should use list comprehensions to filter specific nodes:</p> <pre><code>&gt;&gt;&gt; lin = tax.getAncestry('9606')\n&gt;&gt;&gt; [node for node in lin if node.rank in ['genus', 'family']]\n[Node(9605), Node(9604)]\n&gt;&gt;&gt; len(lin)\n32\n</code></pre> <p>Now that you know the basic functions of taxidTools, you are ready  for the advanced uses.</p>"}]}